// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
/**
 * @description
 * This file contains all the SQL queries for interacting with the 'orders' table.
 * These queries are used by sqlc to generate type-safe Go code for our database access layer.
 */

INSERT INTO orders (
  user_id,
  market_id,
  token_id,
  side,
  size,
  price,
  status,
  signed_order
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at
`

type CreateOrderParams struct {
	UserID      pgtype.UUID    `json:"user_id"`
	MarketID    string         `json:"market_id"`
	TokenID     string         `json:"token_id"`
	Side        string         `json:"side"`
	Size        pgtype.Numeric `json:"size"`
	Price       pgtype.Numeric `json:"price"`
	Status      string         `json:"status"`
	SignedOrder []byte         `json:"signed_order"`
}

// @description Creates a new order in the database with status 'pending'.
// This is called when an order is first placed, before it's submitted to Polymarket.
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.MarketID,
		arg.TokenID,
		arg.Side,
		arg.Size,
		arg.Price,
		arg.Status,
		arg.SignedOrder,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MarketID,
		&i.TokenID,
		&i.PolymarketOrderID,
		&i.Side,
		&i.Size,
		&i.Price,
		&i.Status,
		&i.SignedOrder,
		&i.SubmittedAt,
		&i.FilledAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at FROM orders
WHERE id = $1
LIMIT 1
`

// @description Retrieves a single order by its ID.
func (q *Queries) GetOrderByID(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MarketID,
		&i.TokenID,
		&i.PolymarketOrderID,
		&i.Side,
		&i.Size,
		&i.Price,
		&i.Status,
		&i.SignedOrder,
		&i.SubmittedAt,
		&i.FilledAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrdersByMarketID = `-- name: GetOrdersByMarketID :many
SELECT id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at FROM orders
WHERE market_id = $1
ORDER BY created_at DESC
`

// @description Retrieves all orders for a specific market.
func (q *Queries) GetOrdersByMarketID(ctx context.Context, marketID string) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByMarketID, marketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MarketID,
			&i.TokenID,
			&i.PolymarketOrderID,
			&i.Side,
			&i.Size,
			&i.Price,
			&i.Status,
			&i.SignedOrder,
			&i.SubmittedAt,
			&i.FilledAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserID = `-- name: GetOrdersByUserID :many
SELECT id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at FROM orders
WHERE user_id = $1
ORDER BY created_at DESC
`

// @description Retrieves all orders for a specific user, ordered by creation date (newest first).
func (q *Queries) GetOrdersByUserID(ctx context.Context, userID pgtype.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MarketID,
			&i.TokenID,
			&i.PolymarketOrderID,
			&i.Side,
			&i.Size,
			&i.Price,
			&i.Status,
			&i.SignedOrder,
			&i.SubmittedAt,
			&i.FilledAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserIDAndStatus = `-- name: GetOrdersByUserIDAndStatus :many
SELECT id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at FROM orders
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
`

type GetOrdersByUserIDAndStatusParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Status string      `json:"status"`
}

// @description Retrieves orders for a specific user filtered by status.
func (q *Queries) GetOrdersByUserIDAndStatus(ctx context.Context, arg GetOrdersByUserIDAndStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserIDAndStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MarketID,
			&i.TokenID,
			&i.PolymarketOrderID,
			&i.Side,
			&i.Size,
			&i.Price,
			&i.Status,
			&i.SignedOrder,
			&i.SubmittedAt,
			&i.FilledAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderPolymarketID = `-- name: UpdateOrderPolymarketID :one
UPDATE orders
SET 
  polymarket_order_id = $2,
  updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at
`

type UpdateOrderPolymarketIDParams struct {
	ID                pgtype.UUID `json:"id"`
	PolymarketOrderID pgtype.Text `json:"polymarket_order_id"`
}

// @description Updates the Polymarket order ID after the order is submitted to Polymarket.
func (q *Queries) UpdateOrderPolymarketID(ctx context.Context, arg UpdateOrderPolymarketIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderPolymarketID, arg.ID, arg.PolymarketOrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MarketID,
		&i.TokenID,
		&i.PolymarketOrderID,
		&i.Side,
		&i.Size,
		&i.Price,
		&i.Status,
		&i.SignedOrder,
		&i.SubmittedAt,
		&i.FilledAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET 
  status = $2,
  updated_at = NOW(),
  submitted_at = CASE WHEN $2 = 'open' AND submitted_at IS NULL THEN NOW() ELSE submitted_at END,
  filled_at = CASE WHEN $2 = 'filled' AND filled_at IS NULL THEN NOW() ELSE filled_at END,
  cancelled_at = CASE WHEN $2 = 'cancelled' AND cancelled_at IS NULL THEN NOW() ELSE cancelled_at END
WHERE id = $1
RETURNING id, user_id, market_id, token_id, polymarket_order_id, side, size, price, status, signed_order, submitted_at, filled_at, cancelled_at, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

// @description Updates the status of an order and sets the appropriate timestamp.
// Status can be: 'pending', 'open', 'filled', 'cancelled', 'rejected'
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MarketID,
		&i.TokenID,
		&i.PolymarketOrderID,
		&i.Side,
		&i.Size,
		&i.Price,
		&i.Status,
		&i.SignedOrder,
		&i.SubmittedAt,
		&i.FilledAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
